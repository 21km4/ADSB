\documentclass[dvipdfmx]{jsarticle}

\usepackage{listings}
\usepackage[dvipdfmx]{hyperref}
\usepackage{pxjahyper}
\usepackage{amsmath}

\begin{document}

\lstset{
    frame=single,
    numbers=left
}

\title{アルゴリズムとデータ構造B　グループワーク　報告書}
\author{水本 幸希}
\maketitle

\section{メンバー}
\begin{itemize}
  \item 水本 幸希
  \item 山口 慧
  \item 杣谷 星音
  \item 斧田 洋人
  \item 杉山 亮太
\end{itemize}

\section{基本的な考え方}
与えられたクエリと放送局のデータを切り取ったもの比較して、編集距離が最短となった放送局を答えとする。

\section{編集距離の求め方}

編集距離を求める方法には様々なものが存在するが、今回はビットパラレル法を採用した。
ビットパラレル法は動的計画法を応用しており、ビット演算を利用することで並列処理を行うことで計算時間を短縮している。
動的計画法の場合、計算量は$O(N^2)$であるが、ビットパラレル法を用いると$O(N)$まで計算量を減らすことができる。ただし、この計算量にするには配列の要素数が演算に使用するビット長と同じかそれ以下でなければならない。C言語の場合、使用できる変数の最大ビット長は64ビットであるからクエリの長さが65文字以上だとそのまま適用することができない。そのため今回はクエリの65文字目以降を捨てることで解決させた。これはクエリの長さが長いほど正答率が高くなり、64文字あればほぼ確実に正解を出せるためである。

\subsection{各アルゴリズムでの計測時間の比較}
以下に、様々な方法での実行時間を掲載する。なお、動的計画法での実行時間を100としている。

\begin{table}[htbp]
  \centering
  \begin{tabular}{c|c|c|c}
    動的計画法 & O(ND)アルゴリズム & O(NP)アルゴリズム & ビットパラレル法 \\ \hline\hline
    100 & 65.39 & 25.33 & 1.965 \\ \hline
  \end{tabular}
  \caption{各アルゴリズムでの実行時間}
\end{table}

このように、ビットパラレル法が最も効率良く計算できることが分かる。

\subsection{各アルゴリズムでの計測時間の比較}

\section{放送局の信号分割と打ち切りの条件}

信号をクエリの長さだけ切り取る、ということを全ての箇所で行えば理論上かなり高い確率で当てることができる。ただし、切り取った開始位置の候補は、50万個存在しこれを全て走査して10秒以内に終わらせることは現実的ではない。そのため今回は、放送局の持つ信号からクエリの長さ分だけ信号を切り取って（最初は当然放送局の最初の位置から）編集距離を調べた後、放送局から切り取った信号の開始地点から$(クエリの長さ)/10$だけ右に移動し、再度編集距離を求める、といったことを繰り返すということを繰り返した。この場合、切り取った部分を走査するときは最大で$1/20$ずれる可能性がある。しかし、これ以上細かく走査してもスコアは上がらず、逆に粗くすると正答率が低くなったので、走査するときのステップはこのように設定した。

なお、これだけでも十分時間内に答えを求めることができるが、編集距離が著しく低いものが発見されたらその時点で答えを確定させて打ち切ってしまえば、正答率を下げることなく必要な時間をさらに短縮することができる。具体的には、編集距離がクエリの長さの$1/4$以下になった場合はその場で打ち切っている。これ以上小さくしても結果は変わらず逆に大きくすると、間違える可能性が増加した。

\section{クエリを聞き直す条件}

これまでの工夫で、それなりに正解を出すことができるが信号が短い場合の正答率が低くなってしまう。これは各放送局での最短編集距離が最も小さい放送局が複数存在する場合、最初に発見した放送局を答えとしてしまうようなプログラムにしたことが原因であった。これを解決するため、最短編集距離が最も短いものが複数存在する場合はクエリを聞き直し、それらの放送局に対して最短編集距離を再度求めることで、放送局を確定させた。これによってさらに正答率を上昇させることができた。

\section{苦戦したところ}

今回ビットパラレル法を用いた手法を提案した。この手法では挿入、削除コストは1、置換コストは2となっている（置換は考慮されず、挿入と削除を組み合わせて計算しているため）。色々試したところ、今回の条件では置換コストを2とした方が確実に正答率が上昇したため置換コストは1とすることはしなかった。そのため、挿入、削除率が高い場合でも高いスコアを出すことができるが、置換率が高い状況では高いスコアを出すことが難しかった。特に、クエリの長さが短い場合は正答を出すことが困難であり今回はそれらのケースで確実に正解を出すことは断念した。

\section{没となった案}

メモリピークを抑えるために各データを2ビット（0, 1, 2, 3）に圧縮しようとも考えたが、実行時間が著しく長くなり、制限時間の10秒で処理を終えることが出来なくなってしまったため却下となった。

\section{結果}

以下に100個のテストケースで実行したときのスコアを記載する。（下の二つは最初に配布された10個のテストケースでの平均値）

\begin{itemize}
  \item スコア 968035
  \item 実行時間 1.24 [sec]
  \item メモリピーク 2.209 [MB]
  \item クエリを聞き直した回数 9.7 回
  \item 編集距離が短いものを発見して中断した回数 62.7 回
\end{itemize}

答えを外したのは、クエリが短かったり、置換率が高い場合がほとんどであった。また、エラー率が高い状況では他班と比較して高いスコアが得られたが、逆にエラー率が低い条件では高いスコアを出すことができなかった。

\section{まとめ}

ビットパラレル法を用いて各放送局の最短編集距離を求める
走査は1バイトずつではなく、1回につきクエリの長さの$1/10$だけ右に進めていく
編集距離が著しく短い（クエリの長さの$1/4$以下）場合はその時点で答えを確定させてそのクエリに対する走査は打ち切る
最短編集距離が複数で同一だった場合はクエリを聞き直して再度求めなおす
置換コストは2、挿入、削除コストを1とすると切り取った部分以外との編集距離を増やすため正確に答えを出せる
今回の手法では、「クエリが短い」、「置換率が高い」場合に正答率が低くなる

\section{ソースコード}
以下に今回使用したソースコードを示す。EVALUATE_MODEを定義することで、得点や時間が表示されるように設計した。

\begin{lstlisting}[language=C++]
// #define EVALUATE_MODE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef EVALUATE_MODE
#include <time.h>
#endif

#include "ask.h"

#ifndef INT_MAX
#define INT_MAX 0x7fffffff
#endif

static int p_ins, p_sub, p_del;
static char **S;
static char *q;

#ifdef EVALUATE_MODE
static int abort_count = 0;
static int ask_count = 0;
static int compute_time;

void evaluate(char *argv[])
{
#pragma GCC diagnostic ignored "-Wunused-result"
	FILE *output_file = fopen(argv[2], "r");
	FILE *answer_file = fopen(argv[3], "r");

	int p_ins, p_sub, p_del;
	fscanf(answer_file, "%d %d %d", &p_ins, &p_sub, &p_del);

	int correct = 0, i;
	for (i = 0; i < N; i++)
	{
		int input[N], answer[N];
		char data[N];
		if (fscanf(output_file, "%d", &input[i]) == EOF)
			break;
		fscanf(answer_file, "%d %s", &answer[i], data);
		if (input[i] == answer[i])
			correct++;
	}

	printf("%d\n", correct * 100 - ask_count * 5);
	// printf("%d/%d Correct.\n", correct, i);
	// printf("Score: %d\n", correct * 100 - ask_count * 5);
	// printf("Time: %lf seconds\n", (double)compute_time / CLOCKS_PER_SEC);
	// printf("Ask count: %d\n", ask_count);
	// printf("Abort count: %d\n", abort_count);
	// printf("\n");

	fclose(output_file);
	fclose(answer_file);
#pragma GCC diagnostic warning "-Wunused-result"
}
#endif

#pragma region BITPARALLEL
int weighted_levenshtein_bitpal(char *a, char len_a, char *b, int len_b)
{
	if (len_a > 64)
	{
		return weighted_levenshtein_bitpal(a, 64, b, len_b > 64 ? 64 : len_b);
	}

	unsigned long long posbits[256] = {0};

	for (int i = 0; i < len_a; i++)
	{
		posbits[(unsigned char)a[i]] |= 1ull << i;
	}

	unsigned long long DHneg1 = ~0x0ull;
	unsigned long long DHzero = 0;
	unsigned long long DHpos1 = 0;

	// recursion
	for (int i = 0; i < len_b; i++)
	{
		unsigned long long Matches = posbits[(unsigned char)b[i]];
		// Complement Matches
		unsigned long long NotMatches = ~Matches;

		// Finding the vertical values.
		// Find 1s
		unsigned long long INITpos1s = DHneg1 & Matches;
		unsigned long long DVpos1shift = (((INITpos1s + DHneg1) ^ DHneg1) ^ INITpos1s);

		// set RemainingDHneg1
		unsigned long long RemainDHneg1 = DHneg1 ^ (DVpos1shift >> 1);
		// combine 1s and Matches
		unsigned long long DVpos1shiftorMatch = DVpos1shift | Matches;

		// Find 0s
		unsigned long long INITzeros = (DHzero & DVpos1shiftorMatch);
		unsigned long long DVzeroshift = ((INITzeros << 1) + RemainDHneg1) ^ RemainDHneg1;

		// Find -1s
		unsigned long long DVneg1shift = ~(DVpos1shift | DVzeroshift);
		DHzero &= NotMatches;
		// combine 1s and Matches
		unsigned long long DHpos1orMatch = DHpos1 | Matches;
		// Find 0s
		DHzero = (DVzeroshift & DHpos1orMatch) | (DVneg1shift & DHzero);
		// Find 1s
		DHpos1 = (DVneg1shift & DHpos1orMatch);
		// Find -1s
		DHneg1 = ~(DHzero | DHpos1);
	}
	// find scores in last row
	unsigned long long add1 = DHzero;
	unsigned long long add2 = DHpos1;

	int dist = len_b;

	for (int i = 0; i < len_a; i++)
	{
		unsigned long long bitmask = 1ull << i;
		dist -= ((add1 & bitmask) >> i) * 1 + ((add2 & bitmask) >> i) * 2 - 1;
	}

	return dist;
}
#pragma endregion

int predict_answer(const int index, char *answer_file, const int length, int *ids, const int k)
{
	int ans_id = -1;
	int min_distance = INT_MAX;
	int multiple = 0;
	int ans_ids[N] = {0};
	const int step = length / 10.0;
	for (int j = 0; j < k; j++)
	{
		int id = ids[j];
		for (int i = 0; i < DATA_LENGTH; i += step)
		{
			static char temp[N + 1];
			strncpy(temp, S[id] + i, length);
			temp[length] = '\0';
			int distance = weighted_levenshtein_bitpal(temp, length, q, length);
			if (distance < min_distance)
			{
				min_distance = distance;
				ans_id = id;
				multiple = 0;
				ans_ids[0] = id;
			}
			if (distance == min_distance && ans_id != id)
			{
				if (ans_ids[multiple] != id)
				{
					multiple++;
					ans_ids[multiple] = id;
				}
			}
			if (distance < length / 4.0)
			{
#ifdef EVALUATE_MODE
				abort_count++;
#endif
				return ans_id + 1;
			}
		}
	}
	if (multiple)
	{
		free(q);
#ifdef EVALUATE_MODE
		ask_count++;
#endif
		q = ask(index + 1, answer_file);
		return predict_answer(index, answer_file, strlen(q) + 1, ans_ids, multiple + 1);
	}
	return ans_id + 1;
}

int main(int argc, char *argv[])
{
#pragma GCC diagnostic ignored "-Wunused-result"
#pragma region INITIALIZE
#ifdef EVALUATE_MODE
	compute_time = clock();
#endif
	srand((unsigned int)time(NULL));
	FILE *input_file = fopen(argv[1], "r");
	FILE *output_file = fopen(argv[2], "w");
	FILE *answer_file = fopen(argv[3], "r");
	int ids[N];
	for (int i = 0; i < N; i++)
	{
		ids[i] = i;
	}

	if (!input_file || !output_file || !answer_file)
	{
		fprintf(stderr, "error\n");
		exit(EXIT_FAILURE);
	}

	fscanf(input_file, "%d %d %d", &p_ins, &p_sub, &p_del);

	S = (char **)malloc(sizeof(char *) * N);

	for (int i = 0; i < N; i++)
	{
		S[i] = (char *)malloc(sizeof(char) * (DATA_LENGTH + 1));
		fscanf(input_file, "%s", S[i]);
	}
#pragma endregion

	for (int i = 0; i < Q; i++)
	{
		q = malloc(sizeof(char) * (N + 1));
		fscanf(input_file, "%s", q);
		int length = strlen(q) + 1;

		int answer = predict_answer(i, argv[3], length, ids, N);
		free(q);

		fprintf(output_file, "%d\n", answer);
	}

#pragma region FINALIZE
	fclose(input_file);
	fprintf(output_file, "%lf\n", clock() / (double)CLOCKS_PER_SEC);
	fclose(output_file);
	fclose(answer_file);
	for (int i = 0; i < N; i++)
	{
		free(S[i]);
	}
	free(S);
#pragma endregion
#pragma GCC diagnostic warning "-Wunused-result"

#ifdef EVALUATE_MODE
	compute_time = clock() - compute_time;
	evaluate(argv);
#endif

	return 0;
}
\end{lstlisting}

\begin{thebibliography}{99}
  \item "bitparallel weighted Levenshtein distance". Stackoverflow. \url{https://stackoverflow.com/questions/65363769/bitparallel-weighted-levenshtein-distance} （参照 2022-1-25）
\end{thebibliography}

\end{document}