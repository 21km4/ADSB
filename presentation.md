---
puppeteer:
  format: "A3"
  landscape: false
  printBackground: true
  margin:
    top: 10mm
    bottom: 10mm
    left: 10mm
    right: 10mm
---

# アルゴリズムとデータ構造B グループ発表（Group 9）

## メンバー
- 水本 幸希
- 山口 慧
- 杣谷 星音
- 斧田 洋人
- 杉山 亮太

## 基本コンセプト
与えられたクエリと放送局のデータを切り取ったもの比較して、編集距離が最短となった放送局を答えとする。

## 編集距離の求め方
編集距離を求める方法には様々なものが存在するが、今回はビットパラレル法を採用した。
ビットパラレル法は動的計画法を応用しており、ビット演算を利用することで並列処理を行うことで計算時間を短縮している。
動的計画法の場合、計算量は$O(N^2)$であるが、ビットパラレル法を用いると$O(N)$まで計算量を減らすことができる。ただし、この計算量にするには配列の要素数が演算に使用するビット長と同じかそれ以下でなければならない。C言語の場合、使用できる変数の最大ビット長は64ビットであるからクエリの長さが65文字以上だとそのまま適用することができない。そのため今回はクエリの65文字目以降を捨てることで解決させた。これはクエリの長さが長いほど正答率が高くなり、64文字あればほぼ確実に正解を出せるためである。

bitparallel weighted Levenshtein distance
https://stackoverflow.com/questions/65363769/bitparallel-weighted-levenshtein-distance

## 放送局の信号分割と打ち切りの条件
信号をクエリの長さだけ切り取る、ということを全ての箇所で行えば理論上かなり高い確率で当てることができる。ただし、切り取った開始位置の候補は、50万個存在しこれを全て走査して10秒以内に終わらせることは現実的ではない。そのため今回は、放送局の持つ信号からクエリの長さ分だけ信号を切り取って（最初は当然放送局の最初の位置から）編集距離を調べた後、放送局から切り取った信号の開始地点から$(クエリの長さ)/10$だけ右に移動し、再度編集距離を求める、といったことを繰り返すということを繰り返した。この場合、切り取った部分を走査するときは最大で$1/20$ずれる可能性がある。しかし、これ以上細かく走査してもスコアは上がらなかったので、走査するときのステップはこのようにした。

なお、これだけでも十分時間内に答えを求めることができるが、編集距離が著しく低いものが発見されたらその時点で答えを確定させて打ち切ってしまえば、正答率を下げることなく必要な時間をさらに短縮することができる。具体的には、編集距離がクエリの長さの$1/4$以下になった場合はその場で打ち切っている。

## クエリを聞き直す条件
これまでの工夫で、それなりに正解を出すことができるが信号が短い場合の正答率が低くなってしまう。これは各放送局での最短編集距離が最も小さい放送局が複数存在する場合、最初に発見した放送局を答えとしてしまうようなプログラムにしたことが原因であった。これを解決するため、最短編集距離が最も短いものが複数存在する場合はクエリを聞き直し、それらの放送局に対して最短編集距離を再度求めることで、放送局を確定させた。これによってさらに正答率を上昇させることができた。

## 苦戦したところ
今回ビットパラレル法を用いた手法を提案した。この手法では挿入、削除コストは1、置換コストは2となっている（置換は考慮されず、挿入と削除を組み合わせて計算しているため）。色々試したところ、今回の条件では置換コストを2とした方が確実に正答率が上昇した。これは切り取っていない部分では置換が使えなくなると編集距離が大きくなるためだと考えられる。そのため置換コストは1とすることはしなかった。そのため、挿入、削除率が高い場合でも高いスコアを出すことができるが、置換率が高い状況では高いスコアを出すことが難しかった。特に、クエリの長さが短い場合は正答を出すことが困難であり今回はそれらのケースで確実に正解を出すことは断念した。
また、メモリピークを抑えるために各データを2ビット（0, 1, 2, 3）に圧縮しようとも考えたが、実行時間が著しく長くなるため、これも却下となった。

## まとめ
* ビットパラレル法を用いて各放送局の最短編集距離を求める
* 走査は1バイトずつではなく、1回につきクエリの長さの$1/10$だけ右に進めていく
* 編集距離が著しく短い（クエリの長さの$1/4$以下）場合はその時点で答えを確定させてそのクエリに対する走査は打ち切る
* 最短編集距離が複数で同一だった場合はクエリを聞き直して再度求めなおす
* 置換コストは2、挿入、削除コストを1とすると切り取った部分以外での編集距離を増やすことができ、より正確に答えを出せる
* 今回の手法では、「クエリが短い」、「置換率が高い」場合に正答率が低くなる

## 実行フローチャート
```mermaid
graph TD

開始 --> a[放送局データの読み出し]
a --> b([i番目のクエリを取り出す])
b --> d{クエリの長さが65以上}
d == Yes --> クエリの最初64文字だけを切り取る --> c
d == No --> c

b --> c[放送局からの信号の一部とクエリを比較して編集距離を求める]
c <--> l{編集距離が最短距離よりも短い}
l == Yes --> m[最短距離とその放送局を更新] --> n[最短距離の重複数を0にする] --> c
l == No --> o{最短距離と等しい}
o == Yes --> p[重複した数をインクリメント] --> c
o == No --> c
c == 編集距離が一定値以下 --> e[最短編集距離の放送局を答えとする]
c == 全ての走査が終了 --> h{最短編集距離に重複がある}
h == Yes --> i[クエリを再度聞き直す]
h == No --> e
i == 次の走査は編集距離が同一だった放送局に限定する --> c
e == 次に進む --> b

b == 全てのクエリに対する放送局を特定後 --> j[答えをファイルに書き出す]
j --> k[メモリの解放]
k --> 終了

subgraph クエリに対する放送局を特定
  c & e & h & i & l & m & n & o & p
end

```